
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - shaders - sky sun shader</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>

            body {
                color: #000;
                font-family:Monospace;
                font-size:13px;
                text-align:center;
                font-weight: bold;

                background-color: #fff;
                margin: 0px;
                overflow: hidden;
                text
            }

            #info {
                color:#333;
                text-shadow: 1px 1px #fff;
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;

            }

            a {
                color: #333;
            }

        </style>
    </head>
    <body>

        <div id="info"><a href="http://threejs.org" target="_blank">three.js</a> webgl - sky + sun shader

            <br/><a href="https://plus.google.com/117614030945250277079/posts/MYkgKdvLhNj">More info</a> by <a href="http://twitter.com/blurspline">@blurspline</a>

        </div>

        <script src="js/three.min.js"></script>

        <script src="js/TrackballControls.js"></script>
        <script src="js/SkyShader.js"></script>

        <script src="js/BalancedNode.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/stats.min.js"></script>
        <script src="js/dat.gui.min.js"></script>


        <script>


            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

            var container, stats;

            var camera, controls, scene, renderer;

            var sky, sunSphere;

            var sphereSpread = 1000, sphereDetail=100, sphereMinRadius = 30, sphereMaxRadius =60;
            var sphereDict = [];

            var linkSpread = 70;
            var linkColor =0x0099ff;

            var geometry;
            var material, mesh, lod;
            var max = 100,count = 0;

            init();
            animate();

            function initSky(){

                // Add Sky Mesh
                sky = new THREE.Sky();
                scene.add( sky.mesh );


                // Add Sun Helper
                sunSphere = new THREE.Mesh( new THREE.SphereGeometry( 20000, 30, 30 ),
                                           new THREE.MeshBasicMaterial({color: 0xffffff, wireframe: false }));
                sunSphere.position.y = -700000;
                sunSphere.visible = true;
                scene.add( sunSphere );

                /// GUI

                var effectController  = {
                    turbidity: 10,
                    reileigh: 2,
                    mieCoefficient: 0.005,
                    mieDirectionalG: 0.8,
                    luminance: 1,
                    inclination: 0.49, // elevation / inclination
                    azimuth: 0.25, // Facing front,					
                    sun: !true
                }

                var distance = 400000;

                function guiChanged() {
                    var uniforms = sky.uniforms;
                    uniforms.turbidity.value = effectController.turbidity;
                    uniforms.reileigh.value = effectController.reileigh;
                    uniforms.luminance.value = effectController.luminance;
                    uniforms.mieCoefficient.value = effectController.mieCoefficient;
                    uniforms.mieDirectionalG.value = effectController.mieDirectionalG;

                    var theta = Math.PI * (effectController.inclination - 0.5);
                    var phi = 2 * Math.PI * (effectController.azimuth - 0.5);

                    sunSphere.position.x = distance * Math.cos(phi);
                    sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta); 
                    sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta); 

                    sunSphere.visible = effectController.sun;

                    sky.uniforms.sunPosition.value.copy(sunSphere.position);

                }


                var gui = new dat.GUI();


                gui.add( effectController, "turbidity", 1.0, 20.0, 0.1 ).onChange( guiChanged );
                gui.add( effectController, "reileigh", 0.0, 4, 0.001 ).onChange( guiChanged );
                gui.add( effectController, "mieCoefficient", 0.0, 0.1, 0.001 ).onChange( guiChanged );
                gui.add( effectController, "mieDirectionalG", 0.0, 1, 0.001 ).onChange( guiChanged );
                gui.add( effectController, "luminance", 0.0, 2).onChange( guiChanged );;
                gui.add( effectController, "inclination", 0, 1, 0.0001).onChange( guiChanged );
                gui.add( effectController, "azimuth", 0, 1, 0.0001).onChange( guiChanged );
                gui.add( effectController, "sun").onChange( guiChanged );


                guiChanged();


                camera.lookAt(sunSphere.position)


            }

            function getRandomColor(){
                return Math.random() * 0x808080 + 0x808080;
            }

            function getRandom(min,max)
            {
                return Math.floor(Math.random()*(max-min+1)+min);
            }
            function init() {

                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.5, 2000000 );
                camera.position.z = 2000;

                camera.position.y = 100;
                camera.setLens(20);

                scene = new THREE.Scene();

                var size = 500;

                /*var geometryLines = new THREE.BoxGeometry( size, size, size );

				var geometryPlane = new THREE.PlaneGeometry( size * 10, size * 10, 1, 1);
				geometryPlane.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );


				var materialLines = new THREE.MeshBasicMaterial( { wireframe: true } );

				meshLines = new THREE.Mesh( geometryLines, materialLines );*/

                // scene.add( meshLines );

                /*scene.add( new THREE.Mesh( geometryPlane, materialLines ) );*/

                initSky();
                createScene();

                renderer = new THREE.WebGLRenderer( { antialias: false } );
                renderer.setSize( window.innerWidth, window.innerHeight );

                document.body.appendChild( renderer.domElement );

                controls = new THREE.TrackballControls( camera, renderer.domElement );

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                stats.domElement.style.zIndex = 100;
                document.body.appendChild( stats.domElement );

                //

                window.addEventListener( 'resize', onWindowResize, false );


            }

            function createScene(){
                var s1 = addSphere2("S1");
                var s2 = addSphere2("S2");
                var s3 = addSphere2("S3");
                var s4 = addSphere2("S4");
                var s5 = addSphere2("S5");
                createLink(s1,s2,5);
                createLink(s1,s3,2);
                createLink(s2,s3,30);
                createLink(s4,s3,15);
                createLink(s4,s1,30);
                createLink(s4,s5,11);
            }

            function createLink(s1,s2,n){
                if(n==null)
                    n=1;
                for(i=0;i<n;i++){
                    var link = new THREE.Shape();
                    SUBDIVISIONS = 20;
                    geometry = new THREE.Geometry();
                    curve = new THREE.QuadraticBezierCurve3();
                    curve.v0 = new THREE.Vector3(s1.x, s1.y, s1.z);//pt1
                    curve.v1 = new THREE.Vector3((s1.x+s2.x)/2+linkSpread*Math.random(), 
                                                 (s1.y+s2.y)/2+linkSpread*Math.random(), 
                                                 (s1.z+s2.z)/2+linkSpread*Math.random());//pt2
                    curve.v2 = new THREE.Vector3(s2.x, s2.y, s2.z);//pt3
                    for (j = 0; j < SUBDIVISIONS; j++) {
                        geometry.vertices.push( curve.getPoint(j / SUBDIVISIONS) )
                    }
                    //material = new THREE.LineBasicMaterial( { color: 0x0099ff, linewidth: 2 } );

                    material = new THREE.MeshBasicMaterial({
                        transparent: true,
                        opacity: 0.2,
                        depthTest: false,
                        color: 0x0088ff,
                        blending: THREE.AdditiveBlending
                    });

                    line = new THREE.Line(geometry, material);
                    scene.add(line);	
                }
            }

            function addSphere2(name){
                if(count < max){
                    //G갭굲ie des sources de donn꦳
                    radius = getRandom(sphereMinRadius,sphereMaxRadius);
                    geometry = new THREE.SphereGeometry( radius, sphereDetail, sphereDetail );
                    material = new THREE.MeshBasicMaterial( { color: getRandomColor() } );
                    var cube = new BalancedNode( geometry, material );
                    var x = sphereSpread * ( 0.5 - Math.random() );
                    var y = 0.25*sphereSpread * ( 0.5 - Math.random() );
                    var z = sphereSpread * ( 0.5 - Math.random() );
                    cube.position.x = x;
                    cube.position.y = y;
                    cube.position.z = z;
                    cube.updateMatrix();
                    cube.matrixAutoUpdate = false;
                    var source = {x:x,y:y,z:z,value:cube,radius:radius};
                    sphereDict[name]= source
                    scene.add( cube );
                    count++;
                    return source;
                }
            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

                render();

            }

            var time = 0;

            function animate() {

                time = Date.now();

                requestAnimationFrame( animate );

                controls.update();

                render();

            }

            function render() {

                renderer.render( scene, camera );
                stats.update();

            }


        </script>
    </body>
</html>
