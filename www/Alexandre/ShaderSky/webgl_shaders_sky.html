
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - shaders - sky sun shader</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>

            body {
                color: #000;
                font-family:Monospace;
                font-size:13px;
                text-align:center;
                font-weight: bold;

                background-color: #fff;
                margin: 0px;
                overflow: hidden;
                text
            }

            #info {
                color:#333;
                text-shadow: 1px 1px #fff;
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;

            }

            a {
                color: #333;
            }

        </style>
    </head>
    <body>

        <div id="info"><a href="http://threejs.org" target="_blank">three.js</a> webgl - sky + sun shader

            <br/><a href="https://plus.google.com/117614030945250277079/posts/MYkgKdvLhNj">More info</a> by <a href="http://twitter.com/blurspline">@blurspline</a>

        </div>

        <script src="js/three.min.js"></script>

        <script src="js/TrackballControls.js"></script>
        <script src="js/SkyShader.js"></script>

        <script src="js/BalancedNode.js"></script>
        <script src="js/Arc.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/stats.min.js"></script>
        <script src="js/dat.gui.min.js"></script>


        <script>


            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

            var container, stats;

            var camera, controls, scene, renderer;

            var sky, sunSphere;

            var plane;

            var mouse = new THREE.Vector2(),
                offset = new THREE.Vector3(),
                INTERSECTED, SELECTED;

            var sphereSpread = 1000, sphereDetail=100, sphereMinRadius = 30, sphereMaxRadius =60;
            var sphereDict = [];

            var linkSpread = 70;
            var linkColor =0x0099ff;

            var geometry;
            var material, mesh, lod;

            //tab for nodes ForceLoop
            var sourceNodes = [];
            var arcs = [];
            init();
            animate();

            function init() {
                container = document.createElement( 'div' );
                document.body.appendChild( container );

                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.001, 2000000 );
                camera.position.z = 200;

                camera.position.y = 100;
                camera.setLens(20);

                scene = new THREE.Scene();

                var size = 500;

                initSky();
                createScene();

                renderer = new THREE.WebGLRenderer( { antialias: false } );
                renderer.setSize( window.innerWidth, window.innerHeight );

                container.appendChild( renderer.domElement );

                controls = new THREE.TrackballControls( camera, renderer.domElement );

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                stats.domElement.style.zIndex = 100;
                container.appendChild( stats.domElement );

                //
                renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
                renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
                renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
                window.addEventListener( 'resize', onWindowResize, false );


            }

            function initSky(){

                // Add Sky Mesh
                sky = new THREE.Sky();
                scene.add( sky.mesh );


                // Add Sun Helper
                sunSphere = new THREE.Mesh( new THREE.SphereGeometry( 20000, 30, 30 ),
                                           new THREE.MeshBasicMaterial({color: 0xffffff, wireframe: false }));
                sunSphere.position.y = -700000;
                sunSphere.visible = true;
                scene.add( sunSphere );

                /// GUI

                var effectController  = {
                    turbidity: 10,
                    reileigh: 2,
                    mieCoefficient: 0.005,
                    mieDirectionalG: 0.8,
                    luminance: 1,
                    inclination: 0.49, // elevation / inclination
                    azimuth: 0.25, // Facing front,					
                    sun: !true
                }

                var distance = 400000;

                function guiChanged() {
                    var uniforms = sky.uniforms;
                    uniforms.turbidity.value = effectController.turbidity;
                    uniforms.reileigh.value = effectController.reileigh;
                    uniforms.luminance.value = effectController.luminance;
                    uniforms.mieCoefficient.value = effectController.mieCoefficient;
                    uniforms.mieDirectionalG.value = effectController.mieDirectionalG;

                    var theta = Math.PI * (effectController.inclination - 0.5);
                    var phi = 2 * Math.PI * (effectController.azimuth - 0.5);

                    sunSphere.position.x = distance * Math.cos(phi);
                    sunSphere.position.y = distance * Math.sin(phi) * Math.sin(theta); 
                    sunSphere.position.z = distance * Math.sin(phi) * Math.cos(theta); 

                    sunSphere.visible = effectController.sun;

                    sky.uniforms.sunPosition.value.copy(sunSphere.position);

                }


                var gui = new dat.GUI();


                gui.add( effectController, "turbidity", 1.0, 20.0, 0.1 ).onChange( guiChanged );
                gui.add( effectController, "reileigh", 0.0, 4, 0.001 ).onChange( guiChanged );
                gui.add( effectController, "mieCoefficient", 0.0, 0.1, 0.001 ).onChange( guiChanged );
                gui.add( effectController, "mieDirectionalG", 0.0, 1, 0.001 ).onChange( guiChanged );
                gui.add( effectController, "luminance", 0.0, 2).onChange( guiChanged );;
                gui.add( effectController, "inclination", 0, 1, 0.0001).onChange( guiChanged );
                gui.add( effectController, "azimuth", 0, 1, 0.0001).onChange( guiChanged );
                gui.add( effectController, "sun").onChange( guiChanged );


                guiChanged();


                camera.lookAt(sunSphere.position)


            }

            function getRandomColor(){
                return Math.random() * 0x808080 + 0x808080;
            }

            function getRandom(min,max)
            {
                return Math.floor(Math.random()*(max-min+1)+min);
            }



            function createScene(){
                var s1 = makeSourceNode("S1");
                var s2 = makeSourceNode("S2");
                var s3 = makeSourceNode("S3");
                var s4 = makeSourceNode("S4");
                var s5 = makeSourceNode("S5");
                var s6 = makeSourceNode("S6");
                var s7 = makeSourceNode("S7");
                makeArc(s1,s2,5);
                makeArc(s1,s3,2);
                makeArc(s2,s3,30);
                makeArc(s4,s3,15);
                makeArc(s4,s1,30);
                makeArc(s4,s5,11);
                makeArc(s6,s2,5);
                makeArc(s7,s6,10);

                plane = new THREE.Mesh(
                    new THREE.PlaneBufferGeometry( 2000, 2000, 8, 8 ),
                    new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.25, transparent: true } )
                );
                plane.visible = false;
                scene.add( plane );
            }

            function makeArc(s1,s2,n){
                if(n==null)
                    n=1;
                for(i=0;i<n;i++){
                    /* SUBDIVISIONS = 20;
                    geometry = new THREE.Geometry();
                    curve = new THREE.QuadraticBezierCurve3();
                    curve.v0 = new THREE.Vector3(s1.position.x, s1.position.y, s1.position.z);//pt1
                    curve.v1 = new THREE.Vector3((s1.position.x+s2.position.x)/2+linkSpread*Math.random(), 
                                                 (s1.position.y+s2.position.y)/2+linkSpread*Math.random(), 
                                                 (s1.position.z+s2.position.z)/2+linkSpread*Math.random());//pt2
                    curve.v2 = new THREE.Vector3(s2.position.x, s2.position.y, s2.position.z);//pt3
                    for (j = 0; j < SUBDIVISIONS; j++) {
                        geometry.vertices.push( curve.getPoint(j / SUBDIVISIONS) );
                    }
                    material = new THREE.LineBasicMaterial( { color: 0x0099ff, linewidth: 2 } );

                    material = new THREE.MeshBasicMaterial({
                        transparent: true,
                        opacity: 0.2,
                        depthTest: false,
                        color: 0x0088ff,
                        blending: THREE.AdditiveBlending
                    });

                    line = new THREE.Line(geometry, material);*/
                    material = new THREE.MeshBasicMaterial({
                        transparent: true,
                        opacity: 0.2,
                        depthTest: false,
                        color: 0x0088ff,
                        blending: THREE.AdditiveBlending
                    });
                    var line = new Arc(s1,s2,"Type"+i,material);
                    //line.needsUpdate(true);
                    arcs.push(line);
                    scene.add(line);	
                }
            }

            function makeSourceNode(name){

                radius = getRandom(sphereMinRadius,sphereMaxRadius);
                geometry = new THREE.SphereGeometry( 10, sphereDetail, sphereDetail );
                material = new THREE.MeshBasicMaterial( { color: getRandomColor() } );
                var node = new BalancedNode(name, geometry, material );
                /*var x = sphereSpread * ( 0.5 - Math.random() );
                var y = 0.25*sphereSpread * ( 0.5 - Math.random() );
                var z = sphereSpread * ( 0.5 - Math.random() );
                node.position.x = x;
                node.position.y = y;
                node.position.z = z;*/

                //var source = {x:x,y:y,z:z,value:cube,radius:radius};
                //sphereDict[name]= source

                node.position.set(0,1,100); 
                node.velocity.set(1,0,0);
                node.velocity.rotateZ(Math.random()*90);			
                node.velocity.rotateY(Math.random()*360);

                node.position.rotateZ(Math.random()*360); 

                node.drag = 0.96;

                //node.updateMatrix();
                //node.matrixAutoUpdate = false;

                sourceNodes.push(node);

                scene.add( node );
                return node;
            }

            function makeTypeNode(){
                var particle = new BalancedParticle( new THREE.ParticleBasicMaterial( { map: new THREE.Texture( generateSprite() ), blending: THREE.AdditiveBlending } ));

                particle.scale.x = particle.scale.y = 2;

                particle.position.set(0,1,100); 
                particle.velocity.set(1,0,0);
                particle.velocity.rotateZ(Math.random()*90);			
                particle.velocity.rotateY(Math.random()*360);

                particle.position.rotateZ(Math.random()*360); 

                particle.drag = 0.96;

                particles.push(particle); 

            }

            function expand(sourceNode){
                for(type in sourceNode.types){
                    console.log(type);
                }
            }


            /**BIG EVENTS**/
            function onDocumentMouseMove( event ) {

                event.preventDefault();

                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

                //

                var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );

                var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

                if ( SELECTED ) {

                    var intersects = raycaster.intersectObject( plane );
                    SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );
                    return;

                }

                var intersects = raycaster.intersectObjects( sourceNodes );

                if ( intersects.length > 0 ) {

                    if ( INTERSECTED != intersects[ 0 ].object ) {

                        if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

                        INTERSECTED = intersects[ 0 ].object;
                        INTERSECTED.currentHex = INTERSECTED.material.color.getHex();


                        plane.position.copy( INTERSECTED.position );
                        plane.lookAt( camera.position );

                    }

                    container.style.cursor = 'pointer';

                } else {

                    if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

                    INTERSECTED = null;

                    container.style.cursor = 'auto';

                }

            }

            function onDocumentMouseDown( event ) {

                event.preventDefault();

                var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 ).unproject( camera );

                var raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

                var intersects = raycaster.intersectObjects( sourceNodes );

                if ( intersects.length > 0 ) {

                    controls.enabled = false;

                    SELECTED = intersects[ 0 ].object;

                    if(SELECTED!=null){
                        expand(SELECTED);
                    }

                    var intersects = raycaster.intersectObject( plane );
                    offset.copy( intersects[ 0 ].point ).sub( plane.position );

                    container.style.cursor = 'move';

                }

            }

            function onDocumentMouseUp( event ) {

                event.preventDefault();

                controls.enabled = true;

                if ( INTERSECTED ) {

                    plane.position.copy( INTERSECTED.position );

                    SELECTED = null;

                }

                container.style.cursor = 'auto';

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

                render();

            }


            var time = 0;

            function animate() {

                time = Date.now();

                //Uniform nodes
                var repelforce = new THREE.Vector3(0,0,0),
                    mag, 
                    repelstrength; 

                for (i=0; i<sourceNodes.length; i++){
                    var p1 = sourceNodes[i]; 

                    repelforce.copy(p1.position);

                    mag = repelforce.length(); 

                    repelstrength = (mag - 100) *-1; 

                    if(mag>0){
                        repelforce.multiplyScalar(repelstrength/mag);
                        p1.position.add(repelforce); 
                    }

                    if(i>=sourceNodes.length-1) continue; 

                    for(j=i+1; j<sourceNodes.length; j++) {
                        var p2 = sourceNodes[j];

                        repelforce.copy(p2.position); 
                        repelforce.sub(p1.position); 
                        mag = repelforce.length(); 
                        //repelstrength = 50-mag; 
                        repelstrength = 150-mag; 

                        if((repelstrength>0)&&(mag>0))	{

                            repelforce.multiplyScalar(repelstrength*0.0035 / mag); 

                            p1.force.sub(repelforce); 
                            p2.force.add(repelforce); 

                        }
                    }


                }


                // iteratate through each particle
                for (i=0; i<sourceNodes.length; i++){
                    var sourceNode = sourceNodes[i]; 

                    sourceNode.update();

                }

                // iteratate through each arc
                for (i=0; i<arcs.length; i++){
                    var arc = arcs[i]; 

                    arc.update();

                }

                //end uniform nodes

                requestAnimationFrame( animate );

                controls.update();

                render();

            }

            function render() {

                renderer.render( scene, camera );
                stats.update();

            }


        </script>
    </body>
</html>
